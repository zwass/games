{-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
{-# OPTIONS -Wall #-}

module Games.TicTacToe where

import Test.HUnit
import Data.Binary
import Data.List
import Data.List.Split

import Solver
import PlayableGame

data Piece = E | X | O
           deriving (Show, Eq, Ord)

type TTTBoard = [Piece]

instance Binary Piece where
  put E = putWord8 0
  put X = putWord8 1
  put O = putWord8 2
  get = do
    tag_ <- getWord8
    case tag_ of
      0 -> return E
      1 -> return X
      2 -> return O
      _ -> fail "no parse"

--2D should hopefully make thinking about primitive easier
type Board2D = [[Piece]]

--Store moves as the index of the move counting left to right, top to
--bottom

boardSize :: Int
boardSize = 3

tttGetInitialPosition :: TTTBoard
tttGetInitialPosition = replicate (boardSize * boardSize) E

--Returns a count of each type of piece, Xs first
pieceCounts :: TTTBoard -> (Int, Int)
pieceCounts = foldl'
              (\(x, o) p -> case p of X -> (x + 1, o)
                                      O -> (x, o + 1)
                                      E -> (x, o))
              (0, 0)

tttWhoseTurn :: TTTBoard -> Player
tttWhoseTurn b
  | (fst pCounts) == (snd pCounts) = PlayerOne
  | otherwise = PlayerTwo
  where pCounts = pieceCounts b

--Params are index, piece type, original board
placePiece :: Move -> Piece -> TTTBoard -> TTTBoard
placePiece i t = map (\(li, p) -> if li == i then t else p) . zip [1..]

tttDoMove :: TTTBoard -> Move -> TTTBoard
tttDoMove b m = case (tttWhoseTurn b) of
  PlayerOne -> placePiece m X b
  PlayerTwo -> placePiece m O b

boardTo2D :: [a] -> [[a]]
boardTo2D = chunksOf boardSize

--get all possible indices on the 2D board. This useful?
indexPerms :: [(Int, Int)]
indexPerms = concat $
             map (\x -> zip (repeat x) [1..boardSize]) [1..boardSize]

reflect :: [[a]] -> [[a]]
reflect = map reverse

pieceAt :: Board2D -> (Int, Int) -> Piece
pieceAt b (row, col) = b !! (row-1) !! (col-1)

--Generate rows/diags and pass them to this function to check for 3
--in a row-ness
checkValue :: [Piece] -> Value
checkValue p = case (filter (\l -> length l >= 3) (group p)) of
  [X:_] -> Win
  [O:_] -> Lose
  _ -> Undecided

getRows :: Board2D -> [[Piece]]
getRows = id

getDiag :: Board2D -> (Int, Int) -> [Piece]
getDiag b (row, col)
  | row > boardSize || col > boardSize = []
  | otherwise = pieceAt b (row, col) : getDiag b (row+1, col+1)

getDiags :: Board2D -> [[Piece]]
getDiags b = map (getDiag b) $ zip [1..boardSize] (repeat 1)

--Get all the possible rows/columns and diagonals a player could have
--won on. We can use transpose and reflected to get the columns from
--the rows of the transpose, other diagonal from reflected.
getAllPossibilities :: Board2D -> [[Piece]]
getAllPossibilities b = getDiags b ++ getRows b ++ getDiags bt ++
                        getRows bt ++ getDiags br
                        where bt = transpose b
                              br = reflect b

checkTie :: TTTBoard -> Value
checkTie b = case (E `elem` b) of
  False -> Tie
  True -> Undecided

--Figure out whether someone won or lost
--Check all the rows/cols/diags generated by getAllPossibilities
tttPrimitive :: TTTBoard -> Value
tttPrimitive b = maximum $
              checkTie b : (map checkValue (getAllPossibilities b2d))
              where b2d = boardTo2D b

tttGenerateMoves :: TTTBoard -> [Move]
tttGenerateMoves b = map fst $ filter (\(_, p) -> p == E) $
                  zip [1..] b

instance SolvableGame TTTBoard where
  initialPosition = tttGetInitialPosition
  doMove = tttDoMove
  primitive = tttPrimitive
  generateMoves = tttGenerateMoves
  whoseTurn = tttWhoseTurn

boardToString :: TTTBoard -> String
boardToString b = intercalate divider rows where
  divider = take (maxLen * boardSize + (boardSize - 1)) (repeat '-') ++ "\n"
  rows' = zip [(1 :: Int)..] b
  rows'' = map (\(n, p) -> if p == E then show n else show p) rows'
  maxLen = maximum . map length $ rows''
  rows''' = map (take maxLen . (++ repeat ' ')) rows''
  rows = map ((++ "\n") . intercalate "|") $ boardTo2D rows'''

instance PlayableGame TTTBoard where
  showBoard = boardToString
  showMoves = show

board1 :: TTTBoard
board1 = concat [[X, X, X],
                 [O, O, X],
                 [X, O, O]]

board2 :: TTTBoard
board2 = concat [[X, X, O],
                 [O, O, X],
                 [X, O, O]]

board3 :: TTTBoard
board3 = concat [[O, O, O],
                 [O, X, X],
                 [X, X, E]]


testPrimitive :: Test
testPrimitive = TestList $
                [Win ~=? primitive board1,
                 Tie ~=? primitive board2,
                 Lose ~=? primitive board3]
